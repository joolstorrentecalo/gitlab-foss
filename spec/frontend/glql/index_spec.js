import { nextTick } from 'vue';
import renderGlqlNodes from '~/glql';
import createDefaultClient from '~/lib/graphql';
import Executor from '~/glql/core/executor';
import { MOCK_ISSUES } from './mock_data';

const MOCK_QUERY_RESPONSE = { project: { issues: MOCK_ISSUES } };

jest.mock('~/lib/graphql', () => jest.fn());

describe('renderGlqlNodes', () => {
  let queryFn;

  const mockQueryResponse = (response) => {
    queryFn = jest.fn().mockResolvedValue({ data: response });
    createDefaultClient.mockReturnValue({
      query: queryFn,
    });
  };

  beforeEach(() => {
    mockQueryResponse(MOCK_QUERY_RESPONSE);

    jest.spyOn(Executor.prototype, 'compile');
  });

  it('loops over all glql code blocks and renders them', async () => {
    const container = document.createElement('div');
    container.innerHTML = `
      <pre><code data-canonical-lang="glql">assignee = currentUser()</code></pre>
      <pre><code data-canonical-lang="glql">label = "bug"</code></pre>
    `;

    await renderGlqlNodes(container.querySelectorAll('[data-canonical-lang="glql"]'));

    expect(Executor.prototype.compile).toHaveBeenCalledWith('assignee = currentUser()');
    expect(Executor.prototype.compile).toHaveBeenCalledWith('label = "bug"');

    await nextTick();

    const uls = container.querySelectorAll('ul');
    expect(uls).toHaveLength(2);

    uls.forEach((ul) => {
      expect(ul.innerHTML).toContain('Issue 1');
      expect(ul.innerHTML).toContain('Issue 2');
    });

    expect(container.innerHTML).toContain('Generated by GLQL');
  });
});
